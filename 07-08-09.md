# 실용주의 프로그래머 07, 08, 09

- 10-14 (목)
- 발표자 : 숙련공

## 7. 중복의 해악
* 명세와 프로세스 그리고 프로그램을 개발하는 중에 지식을 중복해서 넣기 쉽다. 이렇게 되면 유지보수의 악몽이 시작될 것이다.
* 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다
  TIP 11 : DRY - 반복하지 마라 (Don’t Repeat Yourself)

> The DRY principle is stated as “Every piece of knowledge must have a *single*, *unambiguous*, *authoritative representation* within a system”.

DRY 원칙은 똑같은 코드를 반복해서 작성하면 안 된다는 원칙이다. 중복 코드가 생기는 순간부터 문제가 발생할 가능성이 높아진다. 개발자는 어떤 코드가 중복인지 알고 있어야 하고, 기능을 수정할 때 모든 중복 코드를 동일하게 수정해야 하고, 수정된 이후에도 개별적인 테스트를 통해 정상적인 결과를 내놓는지 확인해야만 한다. 따라서 변화에 유연하게 대처할 수 있는 코드를 만들기 위해 중복되는 코드를 제거해야 한다. 가능한 코드를 DRY하게 만들어야 한다.

뱅크샐러드-테크 스펙. 귀찮은 일이지만 장기적으로 좋은 방법이다. 큰 규모의 피쳐 개발할 때 활용함. 일련의 과정과 양식, 조건. .. 근데 이것도 결국 주석, 버려질 코멘트… 였다. 자동화가 어렵다.

기획자, 개발자 히스토리 정리 및 관리. 하지않으면 무조건 빵꾸생김.

문서화 어려우면 커밋메시지라도 잘 남기자.

기획자들한테 설명하기 위해서는 코드만으로 힘들다. 개발자들끼리는 코드만 봐도 이해하는게 맞음 ㅇㅇ 커밋메시지는 why를 잘 표현하도록.

지금의 레거시도 그 당시에는 최선의 선택이었다. 꾸준하고 체계적인 코드 관리의 중요성.ㅇㅇ

* 중복이 생기는 이유
	* 강요된 중복
		* 환경이 중복을 요구하는 것처럼 보인다.
		* 안드로이드/iOS, 익스플로러
		* msa에서의 중복 -> 라이브러리 빌드할 때 임포트
		* 해결할 수 있는 방안은?
	* 부주의한 중복
		* 설계 실수
		* 성능상 이유로 DRY 위배 -> 캐싱해야 하는 경우
		* Access 원칙. (set은 당연히 만들지 않는 것이 좋고, get도 최대한 만들지 않는 것이 좋다.)
	* 참을성 없는 중복
		* 중복이 쉬워 보이기 때문에 발생한다
		* 시간의 압박을 받을 수록 유혹을 받을 수 있다
	* 개발자간의 중복
		* 한 프로젝트에서 일하는 여러 사람들이 동일한 정보를 중복.
		* 발견하거나 다루기 가장 어려운 유형
		* 개발자간에 적극적이고 빈번한 소통이 필요 -> 내가 하는 일에대해 지속적으로 공유하라. 토론의 장을 만들어라.
		* 애자일 기법 중 오전에 업무분담해서 오후에 밋업. 어떤 일을 했는지 매일 소통.. 깨끗한 설계 깨끗한 코드..
		* 주단위 스프린트..
		* 주단위 스프린트. 3-4명씩 프젝. 1주일에 한번씩 플래닝-회고…
		* 똑같은듯 ㅇㅇ
		* 같은 프젝을 한느 사람이 많아야하는데 보통 그런 구조가 아니니깐 어렵당
		* 솔직히 한두명은 애자일은 ㅋㅋㅋ 이라고하기엔 ㅠ
		* 최소 3명 ㅇㅇ
		* 프젝뿐만 아니더라도 같은 파트, 다른프젝/ 공유하는게 좋다~~ 일단 플래닝하는게 좋다. 계획 없이 일하는건 안됨!! 그래서 사람이 적으면 플래닝하는데 좋긴하다. ㅇㅎ!
		* 인원.. 팀프하기 가장 좋은 수가 3~6명.
		* 두명이서 해도 무임승차는 있더라;
		  TIP 12 : 재사용하기 쉽게 만들어라

## 8. 직교성
* 컴퓨팅에서는 일종의 독립성이나 *결합도 줄이기*를 의미한다.
* 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교하는 것이다.
* 직교성의 장점
	* 생산성 향상
		* 변화가 국소화(localize) 되어 개발 시간과 테스트 시간이 줄어든다
		* 하나의 퍼블릭 메서드가 있고… 여러 가지 이유로 프라이빗 메서드들로 나눔. 하나의 프라이빗 메서드가 큰 경우… 그 메서드에 여러 역할이 들어가있을 가능성이 크다. 그 역할을 클래스로 뽑아낼 수 있다.
		* 프라이빗 메서드를 어떻게 테스트할까…
		* 꼭 해야겠다고 하면 어노테이션 커스텀해서 만들어놓고. 메서드를 프로텍티드로 바꾸고 테스트함. 사실 맞지는 않는데 결국 공개가되어버려서;; 안좋은 방법. 프라이빗메서드를 호출하는 퍼블릿메서드를 잘 테스트하는게 좋다. ㅡㅡ
		* 재사용을 촉진한다. 시스템이 느슨하게 결합되어 있을수록 재설정하고 리엔지니어링하기 쉽다
	* 리스크 감소
		* 감염된 코드는 격리된다
		* 시스템이 잘 깨지지 않는다
		* 더 많은 테스트를 할 수 있다
		* 써드파티 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정되어 특정 제품, 플랫폼 등에 덜 종속될 수 있다 (db.. 교체해야하는 경우 특정 벤더 종속된 코드가 많으면 어렵다.)
* 프로젝트팀
	* 팀 내 업무가 많이 겹치면 구성원들은 책임 영역에 대해 혼동할 수 있다
	* 개발팀과 인프라팀의 분리
	* 요청된 개별 변화에 대한 토론에 참여해야하는 인원이 클수록 직교성이 낮다고 봐야 한다.
* 설계
	* 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다를 부분과 독립적인 기능을 해야한다
	* 모듈이라는 단어. 이해하기 힘들다. 우리 팀에선 잘 안씀
	* 루비 파이썬은 라이브러리들을 모듈이라 부른다. 패키지로 이해.
	* 각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만을 사용하기 때문에, 코드에 영향을 끼치지 않으면서 아래에 있는 다른 구현을 바꾸는(갈아끼우는) 유연성을 얻을 수 있다. 레이어 격리.
	* 레이어를 두는 것은 또한 모듈 간의 종속성이 빨리 늘어나는 위험을 감소시킨다
* 특정기능에 대한 요구사항을 극적으로 변경한 경우 몇 개의 모듈이 영향을 받는지 생각하면 된다.
* 자신의 힘으로 제어할 수 없는 속성에 의존하지마라
  TIP 13 : 관련 없는 것들 간에 서로 영향이 없도록 하라
* 툴킷과 라이브러리
	* 써드파트 툴킷이나 라이브러리를 도입할 때 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴 봐야 한다
* 코딩
	* 코드의 결합도를 줄여라
		* 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 shy code를 작성하라
		* 디미터 법칙. 묻지 말고 시켜라. 그리고 자기 데이터는 자기가 처리하도록.
	* 전역 데이터를 피하라
		* 코드가 전역 데이터를 참조할 때 마다, 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다.. ABC가 전역데이터를 공유하는 경우.. A가 고쳤는데 B와 C에서도 변경된다는 것을 놓칠수도 있다.
		* 싱글턴 패턴은 특정 클래스가 하나의 객체만을 가지도록 보장해주지만, 주의를 기울여야 한다. 전역상태는 기본적으로 객체지향에서 권장하지 않는다. 싱글턴 객체는 서버 상황에 따라 하나가 아닐 수도 있다. Spring에서는 컨테이너로 직접 (빈)객체들을 싱글턴으로 관리하여 객체지향+싱글턴 패턴
	* 유사한 함수를 피하라
		* 시작과 끝은 같은 코드이고 중간의 알고리즘만 다른 경우,,, 이런 경우도 중복 코드이다. -> 디자인패턴의 ‘스트레티지 패턴’ 을 활용하자.
	* 자신이 작성한 코드를 항상 비판적으로 검토해보는 습관을 기르도록 하자 -> 코드리뷰와 리팩터링
* 테스트
	* 직교적으로 설계, 구현한 시스템은 테스트하기 더 쉽다
	* 모든 모듈이 자신만의 단위 테스트를 위한 테스트케이스를 가지고, 테스트가 정규 빌드 과정의 일부로 수행될 수 있어야 한다
	* 문제가 발생했다면 버그 수정이 얼마나 지역화 되어 있는지 평가하라
* 문서화
* 직교적으로 살아가기

[What is ‘Modal’ and ‘Modeless’ Dialog? Give example and state their uses.](https://www.equestionanswers.com/vcpp/modal-modeless-dialog.php)

## 9. 가역성
* 프로젝트 초기에 항상 최선의 결정은 내리는 것은 아니다
* 결정이 돌에 새겨지는 것이라 가정하고, 발생할지도 모를 우연한 사건들에 대해 준비하지 않는 것 -> 실수가 나온다
* 결정이 돌이 아닌 해변가의 모래 위에 쓰인 글씨라고 생각하자. 언제든 큰 파도가 글씨를 지워버릴 수 있다
  TIP 14 : 최종 결정이란 없다
* 유연한 아키텍처
    * 코드뿐만 아니라 아키텍처, 배포, 벤더 통합 영역의 유연성에 대해서도 관심을 기울여야 한다
    * 벤더 의존적인 수행문들이 코드 전반에  흩어져있다면 이는 유지보수성, 유연성을 떨어트린다.