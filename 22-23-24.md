# 실용주의 프로그래머 22, 23, 24

- 01-20 (목)
- 발표자 : Bale

## 22 죽은 프로그램은 거짓말을 하지 않는다
> 일찍 작동을 멈추게 하라

- ‘그런 일은 절대 일어날 리 없어!’ 라는 사고에 빠지기 쉽다.

> “죽은 프로그램이 입히는 피해는 절름발이 프로그램이 끼치는 것보다 훨씬 덜한법이다”
- 문제되는 코드가 계속 동작을 하는 것보다 일찍 종료되는 것이 낫다. 그 코드가 또 다른 문제를 일으키기 전에 빠르게 멈춰야 한다.
- 불가능한 뭔가가 발생했다는 것을 코드가 발견한다면 프로그램은 더 이상 유효하지 않다고 할 수 있다.
- 이 시점 이후로 하는 일은 모두 수상쩍은 일이므로 되도록 빨리 종료해야 한다.

- 요새는 알람이 잘 되어있어서 그래도 문제 대응이 빠르게 잘 되는 듯 하다. 
- ... 
- 이젠 거의 다 msa로 되어있으니까 자칫하면 연쇄적으로 박살날 수 있는 구조인 것 같다. 그래서 우리는 피쳐를 개발했을때 빠르게 켜고 끌 수 있는 스위치 기능을 만든다.


- 언제든 끌 수 있는 기능을 작업한다는게 제어용 api를 따로 파는건가?
- 스위치? 서버간 호출할때 더이상 다음 서버로 전파가 안되도록 하는것. 그리고 메인 기능에 스위치를 다 다는건 아니고 언제든 변경 가능한 실험적인 기능에 달아 놓는다.


- msa에서… 서버간 통신에서… grpc요런거로 하는거? 
- ㅇㅇ그거로 많이하고 일반 Rest api도 함. 근데 grpc가 rest api랑 같은 통신량일때 4배정도 더 빠르다 함.


- 흠. 만약에 해당 통신이 반드시 성공해야하는건데 실패해… 그럼 어떻게 대응하는지?
- grpc 클라이언트(?)가 있어서 재시도는 기본적으로 함. 어디서 어디를 호출했는지 기록되기때문에 기본적으로 재시도, 타임아웃 등 일반적인 예외 처리 가능.
- 오..!
- 슬로우 쿼리같은 것도 ... 노티받고 어떤 서버에 오래 걸린다가 나옴.


- 재시도는 몇 번 하는지?
- 재시도는 횟수를 정할 수 있음. 보통은 두번까지 디폴트. 특별한 케이스는 5-6번까지. 시간으로 재시도하는 케이스도 있고.. 세부 설정 가능하다.


- 서버들이 도메인별로 나눠져잇다 하면... A-> B-> C가 하나의 트랜잭션으로 묶이는 경우에 재시도 횟수를 중간에 다 써버리면 어떻게 함?
- ..그건 설계가 잘못된거다.
- A 서버 - B 서버 - C 서버가 하나의 트랜잭션으로 묶이면 안되고, (예를 들어) 중간의 B 서버에서 A - B 커넥트를 하나 가지고, B - C 커넥트를 하나 가지도록 구성하는게 더 나을 것 같다. 
> MSA에서의 트랜잭션. 더 고민해볼만한 주제다..


## 23 단정적 프로그래밍
> 단정문을 사용해서 불가능한 상황을 예방하라.

- 테스트가 모든 버그를 발견할 수 없다.

- ‘그런 일은 절대 일어나지 않은거야’ 라는 생각이 든다면 그걸 확인하는 코드를 추가해라. 가장 간단한 방법은 단정문을 사용하는 것이다.

- *assert* 와 같은 매크로를 사용하라.

- 그러나 불필요한 단정문이 너무 많으면 코드가 지저분해진다. 뭐든 적당한게 좋다.

- 단정문은 값의 범위나 타입를 확인하거나 알고리즘 동작을 검사하는 데 유용하다.


- 실제 서버 개발 과정에서 다른 마이크로서비스 서버에 depencendy를 가지는 상황이 많다. ex. 채팅은 IMAG, TEXT 등 내용만 들어온다. 채팅에 여러 이미지가 컬렉션된 새로운 타입의 채팅이 추가되면 관련된 서버에서 반영하지 않으면 다 터질 위험이 있다 ㄷㄷ 
- 이런 맥락으로... 우리팀 토픽을 컨슘하는 쪽에 스펙 공유를 잘 해야한다.
- 결론. msa는 예측할 수 없는 상황에 대해 생각을 잘 해봐야하고 서로 공유를 잘 해야한다.


- 예외 처리에 대한 생각. rest api의 응답으로 데이터만 전달해준다면 클라이언트 쪽에서 에러 코드/상황에 대해 알 수 없어서 좋지 않다. 응답을 ResponseEntity.ok같이 바로 객체 전달해주는 방법이 아니라, 객체를 제네릭타입으로 덮어서 응답값이 뭐고 에러가 발생했으면 무슨 에러인지 구체적인 응답을 보내줘야 한다. CustomResponseEntity<T> 제네릭!


## 24 언제 예외를 사용할까
> 예외는 예외적인 문제에 사용하라.

- 예외는 의외의 상황을 위해 남겨두어야 한다.

- ex. 코드가 어떤 파일을 읽으려 할 때 그 파일이 없는 경우 ->  *파일이 꼭 있어야 하는 경우라면 ‘예외Exception’ 를 발생*시키고, 아니라면 ‘에러Error’ 를 발생시킨다.
- 유닉스 시스템에서 반드시 존재해야하는 */etc/passwd*를 읽으려 했는데 파일이 존재하지 않는 경우는 예외 상황에 해당한다.
- 그러나 사용자가 요청한 임의의 파일을 열때는 그 파일이 존재하지 않을 수도 있기 때문에 예외적인 경우가 아니다.

- 예외는 정상적인 흐름에 사용하지 않고 정말 예외적인 상황에서만 사용해야 한다.


- Python, ruby에서 null exception을 navigator 연산자로 많이 처리한다. 그러나 실제로 error 나 null exception 처리를 해버려서 error report가 제대로 안되는 상황이 발생할 수 있다. navigator가 만능은 아니다.
- obj&.round(2)&.round(2)%…
- 어디서 에러가 나는지 명확히 알 수 없다. 디버깅할때 어렵다.

- 오호 코틀린에서 ?.도 navigator 연산자가 있다.

- 예외처리를 하는 방법은?
- 글로벌 익셉션 try-catch 덕지덕지 쓸 필요 없이 컨트롤러단에서 예외 처리하기
- 흔하진 않지만 스프링에서 제공하는 HandlerExceptionResolver를 쓰기
