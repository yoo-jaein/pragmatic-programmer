# 31~33
코딩하는 동안 해야 할 일들 WHILE YOU ARE CODING  

코딩은 기계적인 작업이 아니다. 사려 깊은 생각과 판단을 통한 결정이 필요하다.

## 31. 우연에 맡기는 프로그래밍
* 행운과 어쩌다 오는 성공에 의존하는 프로그래밍을 하지 말아야 한다.
* 의도적으로 프로그래밍해야 한다.

* 프로그래밍을 우연에 맡기면 어떻게 되는가
	* 처음부터 코드가 왜 잘 돌아가는지 모르는 상태에서 이슈가 발생하면 *코드가 잘 돌아가지 않을 때 이유를 찾을 수 없다.*
	* 중간 과정 전체 이해하기
	* 새로 깨달은게 있으면 히스토리를 남기기(문서화)

* 우연적 구현
	* 속도 -> 빨리 빨리
	* 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일들을 의미한다 .
	* 다음을 생각하자
		* 정말로 제대로 돌아가는 것이 아닐지도 모른다
		* 다른 상황에서는 이상하게 작동할지도 모른다
		* 문서화되지 않는 동작은 라이브러리의 다음 릴리즈에서 변경될 가능성이 있다
		* 불필요한 추가 호출은 코드를 더 느리게 만든다
		* 추가로 호출한 루틴 때문에 새로운 버그들이 코드에 들어올 가능성이 있다

	* 우연적 맥락
		* 그 모듈이 반드시 GUI가 있어야 하는 것인가?
		* 사용자의 언어가 항상 영어일 것인가?
			* 예) 한글/공백 id… *최초 설계의 중요성*
		* 확실한 것이 아닌 것에 의존하면 안된다…

	* 암묵적인 가정
		* *테스팅*은 특히 거짓 원인과 우연적인 결과로 가득찬 영역이다
			* 무수한 가정으로 이루어진 테스트환경.. 무지성 신뢰하게 됨
			* 예상하지 못 한 것을 많이 만나게 됨
		* 가정하지 말라, 증명하라

TIP 44 : 우연에 맡기는 프로그래밍을 하지 말라

* 의도적으로 프로그래밍하기
* *의도를 가지자… 익숙해지지 말자… 우연에 맡기지 말자*
	* *언제나 자기가 지금 무엇을 하고 있는지 알아야 한다*
	* 맹목적으로 코딩하지 말라. *완전하게 이해하지 못한 애플리케이션을 빌드하려 하거나, 익숙하지 않은 기술을 사용하려고 시도하는 행동을 하지 말라*
	* *계획*을 세우고 그것을 바탕으로 진행하라
	* 신뢰할 수 있는 것에만 기대라. 우연한 일이나 가정에 의존하지 말라.
	* *가정*을 문서로 남겨라.
	* 어떤 일이든 실제로 시험해보라
	* 노력을 기울일 대상의 *우선순위*를 정하라. 중요한 것들에 먼저 시간을 투자하라
	* 과거의 노예가 되지말라. *더 이상 적절한 코드가 아니라고 생각되면, 어떤 코드라도 교체하라*


- 새로운 피처를 개발하면서 큰 프로젝트를 진행하면 처음부터 설계를 하는데
- API -> DB -> Kafka -> … 연쇄적으로 비동기 호출되는 구조 (하나의 데이터 -> 여러 DB에서 업데이트 케이스) 
- DB 데이터가 순간적으로 불완전한(멱등성?) 케이스 발견 (찰나) -> 이건 test input/output 직접 넣어서 발견. 테스트 코드(mock)로는 불가
- 그것 때문에 구조를 다 뜯어 고치고 😱
- 0.xx초의 우연일 수 있지만 실제 서비스에서는 *수많은 우연이 발생할 수 있다.*


- 같은 도메인 서버 내에서도 … 비동기는 다 메세징큐로 처리 (yes)
- Spring
- Rails - sidekiq


- 스트레스 테스트(부하테스트) : ngrinder, jmeter

## 32. 알고리즘의 속도
* 빅 오 표기법(Big O Notation)
	* 간단한 반복문
	* 겹친 반복문
	* 반씩 잘라 나가기
	* 나눠서 정복하기
	* 조합적

TIP 45 : 알고리즘의 차수를 추정하라
TIP 46 : 추정을 테스트하라

* 적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.
* 가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다. 입력값의 규모가 작다면 단순한 삽입 정렬과 퀵정렬 간의 큰 차이가 없다.


- 요샌 하드웨어 성능이 많이 올라와서 ㄱㅊ 너무 알고리즘에 목 맬 필요 없다
- 속도가 안 나온다면..
1. 서버 늘리기
2. 비동기 처리하기

- 성능 이슈: 추천 알고리즘
- 추천 로직에서 결과를 db에서 들고오거나 캐시를 써야 하는데 세트를 미리 만들어 놓음
- 4세트 중복 조합 / 상품 8개중 칸 4개 / 8H4
- 사용자 경험을 위해 time 대신 space를 더 쓰는 케이스

- 웹 서버 개발하면서 알고리즘쓸 일이 있을까
- 염두는 해야 한다
- 서비스 개발은 정합성 효율성 … 딱히 알고리즘 활용 x
- 서버 성능이 어느정도 좋으니… 복잡한 알고리즘은 오히려 가독성을 해칠 수 있다 유지보수에 방해됨


- ㅇㅇ 어차피 aws에 서버/메모리 돈을 더 주면 편하게 코드짤 수 있다
- 서비스개발자/플랫폼개발자 : 플랫폼개발자들은 연산 하나하나에도 효율성을 따지는 편. 서비스개발자들은 큰 틀의 설계, 동작 설계 위주로 보는게 중요.

## 33. 리팩터링
* 소프트웨어는 정원일.


* 리팩터링은 언제 해야 하는가
	* 중복 : DRY 원칙의 위반을 발견했을 때
	* 직교성이 좋지 않은 설계 : 직교성을 더 좋게 만들 수 있는 코드나 설계를 발견했을 때
	* 유효기간이 끝난 지식 : 뒤쳐진 코드를 보았을 때
	* 성능 : 성능 개선을 위해서는 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 한다

* 지금 리팩터링을 하지 않으면, 일이 더 진척 되었을 때, 더 많은 시간을 투자해야 할 수도 있다


TIP 47 : 일찍 리팩터링하고, 자주 리팩터링하라

- 매일 한 번씩 (정도)
- Pr 올릴때마다 … 두 세 번
  - "ㅇㅇㅇ리팩터링 했음"

- 리팩터링은 잘 읽히도록

* 클린코드? (3줄-5줄, 너무 짧음, 계속 들어가야 함 왔다갔다)
* 적당히 트레이드오프해라(컴파일/런타임 의존)
* 가독성, 다른 사람이 이해할 수 있는 코드를 써라


한 때 이 명언들에 꽂힌 적 있음
* *함수가 10줄이 넘어가선 안된다*
* *클래스가 100줄이 넘어가선 안된다*
* *디미터의 법칙은 신이다...* 캡슐화 잘 해라

* 리팩터링은 어떻게 하는가
	* 리팩터링의 본질은 재설계다.
	* 1. 리팩터링과 새로운 기능 추가를 동시에 하지 말라 *(모자)*
	* 2. 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다
	* 3. 단계를 작게 나누어서 신중하게 작업한다. 필드를 한 클래스에서 다른 클래스로 옮기기, 비슷한 메서드를 합쳐서 수퍼클래스로 옮기기 등. 리팩터링에서는 국지적인 변경들이 많이 모여서 커다란 규모의 변화를 낳는 일이 자주 발생한다. 단계를 작게 나누고, 한 단계가 끝날 때마다 테스트를 돌린다면, 기나긴 시간의 디버깅 작업을 피할 수 있다.

- 너무 큰 리팩터링은 아예 재설계(처음부터 잘못된 케이스)  
- 몇 년이 지난 코드… 미루고 미루다보면 더이상 해결이 안되는…(현상유지)  


- 객체지향 책 중에서..”아마추어 개발자일 수록 리팩토링을 두려워한다...”
- 아마추어 개발자 맞음^^; 그래도 작은 스텝부터 차근차근 리팩토링 재밌음! 리팩토링을 많이 해볼수록 PR도 잘 보게 되는 듯


리팩토링을 잘하려면?  
1. *테스트를 무조건 잘 짜둬야 한다*
   유닛 단위의 테스트들(+ 통합테스트)이 서로 잘 조화롭게 존재해 테스트 커버리지가 높게 나오는 개발환경
2. 조건문이 필요하면 함수를 분리해본다
3. 변수명 함수명 이름만 잘 바꿔도 훨씬 보기 좋은 코드
4. 함수의 레이어를 생각해본다
5. 등등... 너무나 많은듯
6. 결국 코드도 글이다.. 잘 읽히고 어디든 어울리는 글을 쓰자

—-
리팩토링이 좋다

- 리팩토링을 잘해두면 확실히 미래의 불확실한 비용을 줄일 수 있다
- 과거 모듈 단위로 잘게 쪼개서 오버엔지니어링인가 아닌가 애매한 정도의 개발
- 그런데 요게 최근에 다시 스펙으로 쓰이니 개꿀...
- 어쨌든 스스로 센스껏? 선을 잘지키고 리팩토링 잘하자...